File: FocusSession.swift
================================================================================
//
//  FocusSession.swift
//  FocusIsland
//
//  Created by UT Austin on 8/3/25.
//

import Foundation

enum ExpandedViewMode: Equatable {
    case normal
    case editSessions
}

struct FocusSession: Identifiable, Equatable {
    let id: UUID
    var title: String
    var length: Int      // in seconds
    var completed: Bool

    init(title: String, length: Int, completed: Bool = false) {
        self.id = UUID()
        self.title = title
        self.length = length
        self.completed = completed
    }
}

class FocusIslandState: ObservableObject {
    @Published var sessions: [FocusSession]
    @Published var currentSessionIndex: Int = 0
    @Published var expandedViewMode: ExpandedViewMode = .normal

    // Notification overlay state for completion pop-up
    @Published var showNotification: Bool = false
    @Published var notificationMessage: String = ""

    init(sessions: [FocusSession]) {
        self.sessions = sessions
        self.currentSessionIndex = 0
    }

    var sessionsToShow: [FocusSession] { sessions }
    var editableSessions: [FocusSession] { sessions }

    var currentSession: FocusSession? {
        guard currentSessionIndex < sessions.count else { return nil }
        return sessions[currentSessionIndex]
    }

    /// Remove the current session as soon as it's complete; do NOT increment index.
    func markSessionComplete() {
        guard currentSessionIndex < sessions.count else { return }
        sessions.remove(at: currentSessionIndex)
        // Next session (if any) is at currentSessionIndex now
    }

    func addSession(title: String, length: Int) {
        sessions.append(FocusSession(title: title, length: length))
    }

    func removeSession(id: UUID) {
        if let idx = sessions.firstIndex(where: { $0.id == id }) {
            sessions.remove(at: idx)
            if idx < currentSessionIndex {
                currentSessionIndex -= 1
            }
            currentSessionIndex = max(0, min(currentSessionIndex, sessions.count - 1))
        }
    }

    func updateSession(id: UUID, title: String, length: Int) {
        if let idx = sessions.firstIndex(where: { $0.id == id }) {
            sessions[idx].title = title
            sessions[idx].length = length
        }
    }
}


================================================================================

File: FocusIsland.entitlements
================================================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
	<key>com.apple.security.files.user-selected.read-only</key>
	<true/>
</dict>
</plist>


================================================================================

File: FocusIslandApp.swift
================================================================================
//
//  FocusIslandApp.swift
//  FocusIsland
//
//  Created by UT Austin on 8/2/25.
//

import SwiftUI
import DynamicNotchKit

@main
struct FocusIslandApp: App {
    @NSApplicationDelegateAdaptor(AppDelegate.self) var appDelegate

    var body: some Scene {
        Settings { EmptyView() }
    }
}

class AppDelegate: NSObject, NSApplicationDelegate, ObservableObject {
    let focusState = FocusIslandState(sessions: [
        FocusSession(title: "Homework 1", length: 15),
        FocusSession(title: "Resume Polishing", length: 10),
        FocusSession(title: "Coding Project", length: 10),
        FocusSession(title: "Break", length: 5)
    ])
    let timerModel = TimerModel(sessionDuration: 15)
    var notch: DynamicNotch<ExpandedNotchView, CompactSessionView, CompactTimerView>?

    // Pool of congratulatory messages
    let congratulatoryMessages = [
        "Section complete!",
        "Nice work!",
        "Well done!",
        "Keep it up!",
        "Great focus!",
        "Finished!",
        "Good job!"
    ]

    func applicationDidFinishLaunching(_ notification: Notification) {
        loadCurrentSession()
        notch = DynamicNotch(
            hoverBehavior: .all,
            style: .notch,
            expanded: {
                ExpandedNotchView(
                    state: self.focusState,
                    timerModel: self.timerModel
                )
            },
            compactLeading: { CompactSessionView(state: self.focusState) },
            compactTrailing: { CompactTimerView(timerModel: self.timerModel) }
        )
        Task { await notch?.compact() }
    }

    func loadCurrentSession() {
        guard let session = focusState.currentSession else {
            timerModel.reset(to: 0)
            timerModel.onCompletion = nil
            return
        }
        timerModel.reset(to: session.length)
        timerModel.onCompletion = { [weak self] in
            guard let self = self else { return }
            self.focusState.markSessionComplete() // state changes before next load!
            if self.focusState.currentSession != nil {
                self.focusState.notificationMessage = self.congratulatoryMessages.randomElement() ?? "Section complete!"
                self.focusState.showNotification = true
                DispatchQueue.main.async {
                    Task { await self.notch?.expand() }
                }
            }
        }
    }
}


================================================================================

File: TimerModel.swift
================================================================================
//
//  TimerModel.swift
//  FocusIsland
//
//  Created by UT Austin on 8/3/25.
//


import Foundation

class TimerModel: ObservableObject {
    @Published var secondsRemaining: Int
    @Published var isRunning: Bool = false
    private(set) var totalDuration: Int

    private var timer: Timer?
    var onCompletion: (() -> Void)?

    var progress: Double {
        totalDuration == 0 ? 1.0 : 1.0 - Double(secondsRemaining) / Double(totalDuration)
    }

    var timeDisplay: String {
        String(format: "%d:%02d", secondsRemaining / 60, secondsRemaining % 60)
    }

    init(sessionDuration: Int) {
        self.totalDuration = sessionDuration
        self.secondsRemaining = sessionDuration
    }

    func start() {
        guard !isRunning, secondsRemaining > 0 else { return }
        isRunning = true
        timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { [weak self] _ in
            self?.tick()
        }
    }

    func pause() {
        isRunning = false
        timer?.invalidate()
        timer = nil
    }

    func reset(to seconds: Int? = nil) {
        pause()
        if let s = seconds {
            totalDuration = s
            secondsRemaining = s
        } else {
            secondsRemaining = totalDuration
        }
    }

    private func tick() {
        guard secondsRemaining > 0 else {
            pause()
            onCompletion?()
            return
        }
        secondsRemaining -= 1
        if secondsRemaining == 0 {
            pause()
            onCompletion?()
        }
    }

    deinit {
        pause()
    }
}


================================================================================

File: project_contents.txt
================================================================================


================================================================================

File: OverlayNotchView.swift
================================================================================
//
//  OverlayNotchView.swift
//  FocusIsland
//
//  Created by UT Austin on 8/2/25.
//


import SwiftUI

struct OverlayNotchView: View {
    // Adjust this to your actual Mac's notch width, usually ~90-120
    let notchWidth: CGFloat = 90
    let gapPadding: CGFloat = 16

    @State private var isHovering = false
    @State private var paused = false

    var body: some View {
        HStack(spacing: 0) {
            // Left: Session
            HStack(spacing: 10) {
                Image(systemName: "checkmark.seal.fill")
                    .foregroundColor(.blue)
                    .font(.system(size: 18, weight: .bold))
                Text("Homework 1")
                    .font(.system(size: 15, weight: .semibold))
                    .foregroundColor(.white)
                    .lineLimit(1)
            }
            .padding(.leading, 20)
            .padding(.trailing, gapPadding / 2)
            .frame(minWidth: 110, maxWidth: .infinity, alignment: .trailing)

            // Center: Notch "gap"
            Color.clear
                .frame(width: notchWidth)

            // Right: Timer/Pause
            HStack(spacing: 12) {
                Text("19:42")
                    .font(.system(size: 15, weight: .semibold).monospacedDigit())
                    .foregroundColor(.orange)
                Button(action: { paused.toggle() }) {
                    Image(systemName: paused ? "play.fill" : "pause.fill")
                        .foregroundColor(.white)
                        .padding(6)
                        .background(
                            Circle()
                                .fill(paused ? Color.green : Color.red)
                        )
                }
                .buttonStyle(.plain)
            }
            .padding(.leading, gapPadding / 2)
            .padding(.trailing, 20)
            .frame(minWidth: 100, maxWidth: .infinity, alignment: .leading)
        }
        .padding(.vertical, 10)
        .background(
            Capsule()
                .fill(
                    LinearGradient(
                        gradient: Gradient(colors: [Color(.sRGB, white: 0.10, opacity: 0.97), Color(.sRGB, white: 0.19, opacity: 0.97)]),
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                )
                .shadow(radius: 16)
        )
        .frame(
            minWidth: 295 + notchWidth + gapPadding,
            maxWidth: 350 + notchWidth + gapPadding,
            minHeight: 44,
            maxHeight: 54
        )
        .onHover { hovering in
            withAnimation(.easeInOut(duration: 0.13)) {
                isHovering = hovering
            }
        }
        .scaleEffect(isHovering ? 1.05 : 1)
        .animation(.spring(response: 0.28, dampingFraction: 0.8), value: isHovering)
    }
}


================================================================================

File: CompactTimerView.swift
================================================================================
//
//  CompactTimerView.swift
//  FocusIsland
//
//  Created by UT Austin on 8/2/25.
//


import SwiftUI

struct CompactTimerView: View {
    @ObservedObject var timerModel: TimerModel

    var body: some View {
        HStack(spacing: 10) {
            ZStack {
                Circle()
                    .stroke(Color.gray.opacity(0.5), lineWidth: 4)
                    .frame(width: 19, height: 19)
                Circle()
                    .trim(from: 0, to: timerModel.progress)
                    .stroke(Color.orange, style: StrokeStyle(lineWidth: 4, lineCap: .round))
                    .rotationEffect(.degrees(-90))
                    .frame(width: 19, height: 19)
                Image(systemName: "timer")
                    .resizable()
                    .scaledToFit()
                    .frame(width: 10, height: 10)
                    .foregroundColor(.orange)
            }
            Text(timerModel.timeDisplay)
                .font(.system(size: 14, weight: .medium).monospacedDigit())
                .foregroundColor(.orange)
        }
        .padding(.trailing, 14)
        .padding(.vertical, 2)
        .background(Color.clear)
    }
}


================================================================================

File: ExpandedNotchView.swift
================================================================================
//
//  ExpandedNotchView.swift
//  FocusIsland
//
//  Created by UT Austin on 8/2/25.
//

import SwiftUI

struct ExpandedNotchView: View {
    @ObservedObject var state: FocusIslandState
    @ObservedObject var timerModel: TimerModel

    // Editing state for Add/Edit
    @State private var editingSessionID: UUID? = nil
    @State private var newTitle: String = ""
    @State private var editHour: String = "0"
    @State private var editMin: String = "0"
    @State private var editSec: String = "0"
    @State private var newLength: String = "" // compatibility

    // Notification <-> main overlay animation
    @State private var showingMainOverlay = false

    private let maxOverlayWidth: CGFloat = 1000
    private let minOverlayWidth: CGFloat = 540
    private let maxUpcomingToShow: Int = 5

    var body: some View {
        ZStack {
            if state.showNotification && !showingMainOverlay {
                NotificationView(
                    message: state.notificationMessage,
                    onHover: {
                        withAnimation(.easeInOut(duration: 0.33)) {
                            showingMainOverlay = true
                            state.showNotification = false
                        }
                        // Only signal AppDelegate to load the next session/timer after notification overlay dismisses.
                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.34) {
                            if let app = NSApplication.shared.delegate as? AppDelegate {
                                app.loadCurrentSession()
                            }
                        }
                    }
                )
                .frame(minWidth: 370, maxWidth: 470, minHeight: 120, maxHeight: 155)
                .transition(.scale.combined(with: .opacity))
            }
            // Show full overlay if not showing notification, or after animated transition
            if !state.showNotification || showingMainOverlay {
                mainExpandedContent
                    .transition(.scale.combined(with: .opacity))
            }
        }
        .onChange(of: state.showNotification) { show in
            if show { showingMainOverlay = false }
        }
        .animation(.easeInOut(duration: 0.33), value: showingMainOverlay)
    }

    private var mainExpandedContent: some View {
        Group {
            switch state.expandedViewMode {
            case .editSessions:
                EditSessionsView(
                    state: state,
                    editingSessionID: $editingSessionID,
                    newTitle: $newTitle,
                    editHour: $editHour,
                    editMin: $editMin,
                    editSec: $editSec,
                    newLength: $newLength
                )
            case .normal:
                let session = state.currentSession ?? FocusSession(title: "--", length: 1)
                HStack(alignment: .top, spacing: 0) {
                    // LEFT: Current session details
                    VStack(alignment: .center, spacing: 14) {
                        HStack(spacing: 8) {
                            Image(systemName: "checkmark.seal.fill")
                                .foregroundColor(.blue)
                                .font(.system(size: 24, weight: .bold))
                            Text(session.title)
                                .font(.system(size: 18, weight: .bold))
                                .foregroundColor(.white)
                                .lineLimit(1)
                                .truncationMode(.tail)
                                .layoutPriority(1)
                        }
                        .padding(.horizontal, 8)
                        .frame(minWidth: 60, maxWidth: .infinity, alignment: .center)
                        Text("Current session in progress…")
                            .foregroundColor(.white.opacity(0.7))
                            .font(.footnote)
                    }
                    .frame(minWidth: 110, alignment: .center)

                    Divider()
                        .frame(width: 1)
                        .background(.white.opacity(0.12))
                        .padding(.vertical, 10)

                    // CENTER: Timeline, capped + more indicator
                    VStack(alignment: .leading, spacing: 12) {
                        HStack {
                            Text("Upcoming Timeline")
                                .font(.caption)
                                .foregroundColor(.gray)
                            Spacer()
                            Button {
                                state.expandedViewMode = .editSessions
                            } label: {
                                Image(systemName: "pencil.circle.fill")
                                    .foregroundColor(.orange)
                                    .font(.title3)
                            }
                            .buttonStyle(.plain)
                            .help("Edit sessions")
                        }
                        ForEach(
                            Array(state.sessionsToShow.prefix(maxUpcomingToShow).enumerated()),
                            id: \.element.id
                        ) { idx, s in
                            HStack {
                                Text(s.title)
                                    .foregroundColor(.white)
                                    .fontWeight(idx == 0 ? .bold : .regular)
                                Spacer()
                                Text(formattedLength(s.length))
                                    .foregroundColor(.orange)
                                    .font(.caption2.monospacedDigit())
                            }
                        }
                        if state.sessionsToShow.count > maxUpcomingToShow {
                            let remaining = state.sessionsToShow.count - maxUpcomingToShow
                            HStack {
                                Image(systemName: "ellipsis")
                                    .foregroundColor(.gray)
                                Text("and \(remaining) more…")
                                    .foregroundColor(.gray)
                                    .font(.caption)
                                    .lineLimit(1)
                                Spacer()
                            }
                            .opacity(0.7)
                        }
                        Spacer(minLength: 10)
                    }
                    .frame(minWidth: 180, maxWidth: 270, alignment: .leading)
                    .padding(.horizontal, 20)

                    Divider()
                        .frame(width: 1)
                        .background(.white.opacity(0.12))
                        .padding(.vertical, 10)

                    // RIGHT: Timer + start/pause
                    VStack(alignment: .center, spacing: 14) {
                        Text(timerModel.timeDisplay)
                            .font(.system(size: 27, weight: .bold).monospacedDigit())
                            .foregroundColor(.orange)
                        ZStack {
                            Circle()
                                .stroke(Color.gray.opacity(0.5), lineWidth: 6)
                                .frame(width: 48, height: 48)
                            Circle()
                                .trim(from: 0, to: timerModel.progress)
                                .stroke(Color.orange, style: StrokeStyle(lineWidth: 6, lineCap: .round))
                                .rotationEffect(.degrees(-90))
                                .frame(width: 48, height: 48)
                            Button(action: {
                                timerModel.isRunning ? timerModel.pause() : timerModel.start()
                            }) {
                                Image(systemName: timerModel.isRunning ? "pause.fill" : "play.fill")
                                    .resizable()
                                    .scaledToFit()
                                    .frame(width: 24, height: 24)
                                    .foregroundColor(.orange)
                                    .padding(8)
                                    .offset(x: timerModel.isRunning ? 0 : 2)
                            }
                            .buttonStyle(.plain)
                        }
                        Text(timerModel.isRunning ? "Pause Session" : "Resume Session")
                            .font(.footnote)
                            .foregroundColor(.white.opacity(0.76))
                    }
                    .frame(minWidth: 120, maxWidth: 150)
                }
                .padding(.vertical, 20)
                .padding(.horizontal, 24)
                .fixedSize(horizontal: true, vertical: false)
                .frame(
                    minWidth: minOverlayWidth,
                    maxWidth: maxOverlayWidth
                )
            }
        }
    }

    private func formattedLength(_ seconds: Int) -> String {
        let h = seconds / 3600
        let m = (seconds % 3600) / 60
        let s = seconds % 60
        if h > 0 {
            return String(format: "%d:%02d:%02d", h, m, s)
        } else {
            return String(format: "%d:%02d", m, s)
        }
    }
}

// --- EDIT SESSIONS PAGE --- //
struct EditSessionsView: View {
    @ObservedObject var state: FocusIslandState
    @Binding var editingSessionID: UUID?
    @Binding var newTitle: String
    @Binding var editHour: String
    @Binding var editMin: String
    @Binding var editSec: String
    @Binding var newLength: String // unused

    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            HStack {
                Text("Edit Sessions")
                    .font(.system(size: 20, weight: .bold))
                    .foregroundColor(.white)
                Spacer()
                Button("Done") {
                    state.expandedViewMode = .normal
                }
                .font(.system(size: 15, weight: .bold))
                .buttonStyle(.borderedProminent)
                .padding(.trailing, 2)
            }
            .padding(.bottom, 8)

            ScrollView {
                VStack(spacing: 15) {
                    ForEach(state.sessions, id: \.id) { s in
                        HStack(spacing: 44) {
                            if editingSessionID == s.id {
                                TextField("Title", text: $newTitle)
                                    .font(.system(size: 16))
                                    .textFieldStyle(.roundedBorder)
                                    .frame(minWidth: 120, maxWidth: 220)
                                HStack(spacing: 7) {
                                    TextField("Hr", text: $editHour)
                                        .font(.system(size: 15))
                                        .frame(width: 35)
                                        .textFieldStyle(.roundedBorder)
                                    Text(":")
                                        .font(.system(size: 15, weight: .bold))
                                        .foregroundColor(.gray)
                                    TextField("Min", text: $editMin)
                                        .font(.system(size: 15))
                                        .frame(width: 35)
                                        .textFieldStyle(.roundedBorder)
                                    Text(":")
                                        .font(.system(size: 15, weight: .bold))
                                        .foregroundColor(.gray)
                                    TextField("Sec", text: $editSec)
                                        .font(.system(size: 15))
                                        .frame(width: 35)
                                        .textFieldStyle(.roundedBorder)
                                }
                                Button("Save") {
                                    let hour = Int(editHour) ?? 0
                                    let min = Int(editMin) ?? 0
                                    let sec = Int(editSec) ?? 0
                                    let totalSec = hour * 3600 + min * 60 + sec
                                    if !newTitle.isEmpty, totalSec > 0 {
                                        state.updateSession(id: s.id, title: newTitle, length: totalSec)
                                        editingSessionID = nil
                                    }
                                }
                                .font(.system(size: 15, weight: .bold))
                                .buttonStyle(.borderedProminent)
                                Button("Cancel") {
                                    editingSessionID = nil
                                }
                                .font(.system(size: 14, weight: .regular))
                                .buttonStyle(.bordered)
                            } else {
                                Text(s.title)
                                    .font(.system(size: 16))
                                    .foregroundColor(.white)
                                    .lineLimit(1)
                                    .truncationMode(.tail)
                                    .frame(minWidth: 120, maxWidth: 220, alignment: .leading)
                                Text(formattedHourMinSec(s.length))
                                    .font(.system(size: 15, design: .monospaced))
                                    .foregroundColor(.orange)
                                    .frame(width: 70, alignment: .leading)
                                Button {
                                    newTitle = s.title
                                    let (h, m, sec) = secondsToHMS(s.length)
                                    editHour = "\(h)"
                                    editMin = "\(m)"
                                    editSec = "\(sec)"
                                    editingSessionID = s.id
                                } label: {
                                    Image(systemName: "pencil")
                                        .font(.system(size: 17))
                                }
                                .buttonStyle(.plain)
                                .help("Edit session")
                                Button {
                                    state.removeSession(id: s.id)
                                } label: {
                                    Image(systemName: "trash")
                                        .font(.system(size: 17))
                                        .foregroundColor(.red)
                                }
                                .buttonStyle(.plain)
                                .help("Delete session")
                            }
                        }
                        .padding(.vertical, 6)
                    }
                    if editingSessionID == nil {
                        HStack(spacing: 44) {
                            TextField("Title", text: $newTitle)
                                .font(.system(size: 16))
                                .textFieldStyle(.roundedBorder)
                                .frame(minWidth: 120, maxWidth: 220)
                            HStack(spacing: 7) {
                                TextField("Hr", text: $editHour)
                                    .font(.system(size: 15))
                                    .frame(width: 35)
                                    .textFieldStyle(.roundedBorder)
                                Text(":")
                                    .font(.system(size: 15, weight: .bold))
                                    .foregroundColor(.gray)
                                TextField("Min", text: $editMin)
                                    .font(.system(size: 15))
                                    .frame(width: 35)
                                    .textFieldStyle(.roundedBorder)
                                Text(":")
                                    .font(.system(size: 15, weight: .bold))
                                    .foregroundColor(.gray)
                                TextField("Sec", text: $editSec)
                                    .font(.system(size: 15))
                                    .frame(width: 35)
                                    .textFieldStyle(.roundedBorder)
                            }
                            Button("Add") {
                                let hour = Int(editHour) ?? 0
                                let min = Int(editMin) ?? 0
                                let sec = Int(editSec) ?? 0
                                let totalSec = hour * 3600 + min * 60 + sec
                                if !newTitle.isEmpty, totalSec > 0 {
                                    state.addSession(title: newTitle, length: totalSec)
                                    newTitle = ""
                                    editHour = "0"
                                    editMin = "0"
                                    editSec = "0"
                                }
                            }
                            .font(.system(size: 15, weight: .bold))
                            .buttonStyle(.borderedProminent)
                        }
                        .padding(.vertical, 6)
                    }
                }
            }
            .frame(maxHeight: 400)
            Spacer()
        }
        .padding(.vertical, 20)
        .padding(.horizontal, 60)
        .fixedSize(horizontal: true, vertical: false)
        .frame(
            minWidth: 620, maxWidth: 900
        )
        .transition(.scale.combined(with: .opacity))
    }

    private func formattedHourMinSec(_ seconds: Int) -> String {
        let h = seconds / 3600
        let m = (seconds % 3600) / 60
        let s = seconds % 60
        if h > 0 {
            return String(format: "%d:%02d:%02d", h, m, s)
        } else {
            return String(format: "%d:%02d", m, s)
        }
    }
    private func secondsToHMS(_ seconds: Int) -> (Int, Int, Int) {
        let h = seconds / 3600
        let m = (seconds % 3600) / 60
        let s = seconds % 60
        return (h, m, s)
    }
}

struct NotificationView: View {
    let message: String
    var onHover: (() -> Void)? = nil

    var body: some View {
        HStack(spacing: 20) {
            ZStack {
                Circle()
                    .fill(Color.orange)
                    .frame(width: 34, height: 34)
                Image(systemName: "bell.fill")
                    .foregroundColor(.white)
                    .font(.system(size: 18, weight: .heavy))
            }
            VStack(alignment: .leading, spacing: 2) {
                Text("Time's Up!")
                    .font(.system(size: 18, weight: .bold))
                    .foregroundColor(.orange)
                Text(message)
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundColor(.white)
            }
        }
        .padding(.vertical, 32)
        .padding(.horizontal, 44)
        .frame(minWidth: 350, maxWidth: 440)
        .background(
            RoundedRectangle(cornerRadius: 30, style: .continuous)
                .fill(Color(.sRGB, white: 0.11, opacity: 0.95))
        )
        .shadow(color: Color.black.opacity(0.21), radius: 12, y: 4)
        .onHover { hovering in
            if hovering {
                onHover?()
            }
        }
    }
}


================================================================================

File: CompactSessionView.swift
================================================================================
//
//  CompactSessionView.swift
//  FocusIsland
//
//  Created by UT Austin on 8/2/25.
//


import SwiftUI

struct CompactSessionView: View {
    @ObservedObject var state: FocusIslandState

    var body: some View {
        HStack(spacing: 9) {
            Image(systemName: "checkmark.seal.fill")
                .foregroundColor(.blue)
                .font(.system(size: 15, weight: .bold))
            Text(state.currentSession?.title ?? "--")
                .font(.system(size: 14, weight: .semibold))
                .foregroundColor(.white)
                .lineLimit(1)
        }
        .padding(.leading, 14)
        .padding(.vertical, 2)
        .background(Color.clear)
    }
}


================================================================================

